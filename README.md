# lessone4.2
# наследование и инкапсуляция

C:/Users/Щетинин Д Б/Documents/GitHub/lessone4.2/main0.py
Этот код на языке Python определяет два класса: User и Admin.
Класс User имеет два метода: user_id и name.
Метод user_id возвращает атрибут __user_id, а name возвращает атрибут __name.
Класс Admin имеет метод add_user, remove_user и edit_user.
Метод add_user добавляет пользователя user в список users_list.
Метод remove_user удаляет пользователя user из списка users_list.
Метод edit_user изменяет имя пользователя user в списке users_list.
Код создает экземпляр класса Admin с именем admin и вызывает его метод edit_user.
В результате в консоли будет выведено сообщение 'User John edited successfully.'
В итоге этот код демонстрирует объектно-ориентированное программирование (ООП) в Python,
 где пользователь может добавлять, удалять и редактировать других пользователей.

C:/Users/Щетинин Д Б/Documents/GitHub/lessone4.2/main1.py
Этот код на языке Python определяет два класса: User и Admin.
Класс User имеет два метода: user_id и name.
Метод user_id возвращает атрибут __user_id, а name возвращает атрибут __name.
Класс Admin имеет метод add_user, remove_user и edit_user.
Метод add_user добавляет пользователя user в список users_list.
Метод remove_user удаляет пользователя user из списка users_list.
Метод edit_user изменяет имя пользователя user в списке users_list.
Код создает экземпляр класса Admin с именем admin и вызывает его метод edit_user.
В результате в консоли будет выведено сообщение 'User John edited successfully.'
В итоге этот код демонстрирует объектно-ориентированное программирование (ООП) в Python,
 где пользователь может добавлять, удалять и редактировать других пользователей.

C:/Users/Щетинин Д Б/Documents/GitHub/lessone4.2/main3.py
Этот код Python определяет класс Test, который имеет три атрибута: public, _protected и __private.
Метод __init__ инициализирует эти атрибуты.
У класса также есть два метода: get_private и set_private, которые позволяют получать
 и устанавливать значение атрибута __private.
Код создает экземпляр класса Test с именем test и выводит значения атрибутов public и __private.
Затем он устанавливает атрибут __private в новое значение и снова выводит его на печать.

C:/Users/Щетинин Д Б/Documents/GitHub/lessone4.2/main4.py
Этот код на языке Python определяет класс Test с четырьмя методами:
 public_func(): Это публичный метод, который печатает «This is public function».
 _protected_func():
Это защищенный метод (условно обозначается префиксом с одним подчеркиванием),
  который печатает «Это защищенная функция».
 __private_func(): Это приватный метод (условно обозначается двумя префиксами подчеркивания),
  который выводит «Это приватная функция».
 test_private(): Этот метод вызывает приватный метод __private_func().
Затем класс инстанцируется как объект test, и вызываются публичный и приватный методы.
Защищенный метод не вызывается, потому что он предназначен для внутреннего использования
 внутри класса и не предназначен для доступа извне.
Примечание: В Python нет строгих требований к приватным методам.
Они по-прежнему доступны и могут быть вызваны, но, как правило,
 считается хорошей практикой избегать этого, поскольку это может привести к путанице и потенциальным ошибкам.

C:/Users/Щетинин Д Б/Documents/GitHub/lessone4.2/main5.py
Этот код на языке Python определяет два класса: Engine и Car.
Класс Engine имеет два метода: start() и stop().
Метод start() выводит на консоль сообщение 'Starting the engine...',
 а метод stop() выводит сообщение 'Stopping the engine...'.
Класс Car имеет метод __init__, который инициализирует новый экземпляр Car с экземпляром Engine.
Метод start() класса Car вызывает метод start() экземпляра Engine,
 а метод stop() класса Car вызывает метод stop() экземпляра Engine.
Затем код создает новый экземпляр Car с именем my_Car и вызывает его методы start() и stop().
В результате в консоли будут выведены сообщения 'Starting the engine...' и 'Stopping the engine...'.
В итоге этот код демонстрирует объектно-ориентированное программирование (ООП) в Python,
 где автомобиль имеет двигатель и может запускать и останавливать его.

C:/Users/Щетинин Д Б/Documents/GitHub/lessone4.2/main6.py
Этот код на языке Python определяет два класса: Teacher и School.#
Класс Teacher имеет метод teach(),
 который печатает «Преподаватель учит» (что в переводе на русский означает «Учитель учит»).
Класс School имеет метод __init__(),
 который принимает в качестве аргумента объект new_teacher и присваивает его атрибуту teacher.
У него также есть метод start_lesson(), который вызывает метод teach() объекта teacher.
Затем код создает объект my_teacher класса Teacher и объект my_school класса School,
 передавая my_teacher в качестве аргумента конструктору School.
Затем он печатает объекты my_teacher и my_school и вызывает метод start_lesson() для my_school,
 который, в свою очередь, вызывает метод teach() для my_teacher.

C:/Users/Щетинин Д Б/Documents/GitHub/lessone4.2/main7.py
Этот код определяет два класса, Dog и Cat, у которых есть метод speak,
 возвращающий строку. Функция animal_speak принимает в качестве аргумента
 объект класса Dog или Cat и вызывает на нем метод speak.
Код создает экземпляры Dog и Cat, а затем вызывает animal_speak на каждом из них,
 чтобы распечатать соответствующие звуки животных.

C:/Users/Щетинин Д Б/Documents/GitHub/lessone4.2/main8.py
В этом примере код создает классы Dog, Cat и Cow, которые представляют животные.
Затем код создает список объектов Animal, каждый из которых представляет отдельное животное,
 и выполняет итерации по списку, вызывая метод make_sound для каждого объекта.
В результате программа напечатает «Гав!», «Мяу» и «Мууу» соответственно.

C:/Users/Щетинин Д Б/Documents/GitHub/lessone4.2/main9.py
Этот фрагмент кода определяет иерархию классов для различных фигур.
 Базовым классом является класс Shape, который имеет метод area(), возвращающий 0.
Классы Circle, Rectangle, Square, Trapezoidal и Ellipse наследуют от класса Shape
 и переопределяют метод area() для вычисления площади каждой конкретной фигуры.
Код также включает функцию print_area(), которая принимает объект фигуры в качестве аргумента
 и печатает площадь этой фигуры. Наконец, код создает экземпляры каждого класса фигур
 и вызывает функцию print_area(), чтобы вывести площадь каждой фигуры.

C:/Users/Щетинин Д Б/Documents/GitHub/lessone4.2/main10.py
В этом фрагменте кода определены два класса: Author и Book.
Класс Author имеет метод __init__, который принимает в качестве параметров имя и национальность
 и присваивает их переменным экземпляра self.name и self.nationality, соответственно.
Класс Book также имеет метод __init__, который принимает в качестве параметров title и author
 и присваивает их переменным экземпляра self.title и self.author, соответственно.
Класс Book также имеет метод get_info_book, который выводит название, имя и национальность книги.
В фрагменте кода создается экземпляр класса Author с именем 'George R. R. Martin'
 и национальностью 'American'. Затем создается экземпляр класса Book с названием 'Игра Престолов'
 и ранее созданным экземпляром Author в качестве автора.
На экземпляре Book вызывается метод get_info_book, который выводит название, имя и национальность книги.
Наконец, имя и национальность автора и название книги выводятся отдельно.

C:/Users/Щетинин Д Б/Documents/GitHub/lessone4.2/new.py
Этот код на языке Python определяет два класса: Car и ElectricCar.
Класс Car имеет три атрибута: public_make, _protected_model и __private_year. 
Атрибут public_make доступен извне класса, а _protected_model и __private_year являются защищенным 
 и приватным атрибутами соответственно, то есть доступ к ним возможен только изнутри класса или его подклассов.
Класс Car также имеет три метода: public_method(), protected_method() и private_method(). 
Метод public_method() возвращает строку, содержащую марку и модель автомобиля, 
 а методы protected_method() и private_method() возвращают защищенную и частную модель соответственно.
Класс ElectricCar является подклассом Car и добавляет дополнительный атрибут battery_size. 
Он также переопределяет метод get_details(), чтобы включить размер батареи в подробную информацию об электромобиле.
Код создает экземпляр класса Car под названием my_car и печатает результат вызова метода public_method(). 
Затем создается экземпляр класса ElectricCar с именем electric_car и выводится результат вызова метода get_details().

zoo.py
Этот фрагмент кода определяет симулятор зоопарка на Python. 
Он включает в себя классы для животных, смотрителей зоопарка и ветеринаров, 
 а также класс Zoo, который управляет животными и персоналом. 
Код демонстрирует полиморфизм, поскольку функция animal_sound может принимать список животных 
 и вызывать их метод make_sound. 
Зоопарк можно сохранять и загружать из файлов различных форматов, включая pickle, JSON и текст.


# Инструмент Mangling критерии использования по принципам объектно-ориентированного программирования языка Python

В объектно-ориентированном программировании на языке Python существует концепция манглинга (name mangling), 
 которая используется для создания "частных" атрибутов в классах. 
Манглинг имен — это механизм, который изменяет имена атрибутов, чтобы сделать их менее доступными из внешнего кода 
 и избежать конфликтов имен в подклассах. Это достигается путем добавления префикса `_ClassName` к имени атрибута.

Вот основные критерии и правила использования манглинга имен в Python:

1. **Двойное подчеркивание перед именем**:
   Если вы хотите сделать атрибут "частным" (то есть, недоступным напрямую из вне класса), 
    вы должны использовать двойное подчеркивание перед его именем:
   ```python
   class MyClass:
       def __init__(self):
           self.__private_attr = 42
   ```

2. **Изменение имени**:
   Python автоматически изменяет имя атрибута, добавляя к нему префикс `_ClassName`, 
    чтобы сделать его менее доступным:
   ```python
   obj = MyClass()
   print(obj.__dict__)  # {'_MyClass__private_attr': 42}
   ```

3. **Доступ к манглированным атрибутам**:
   Хотя манглинг имен делает атрибуты менее доступными, это не делает их полностью недоступными. 
   Вы все еще можете получить доступ к таким атрибутам, используя их измененные имена:
   ```python
   print(obj._MyClass__private_attr)  # 42
   ```

4. **Использование в наследовании**:
   Манглинг имен помогает избежать конфликтов имен в подклассах. 
   Например:
   ```python
   class Base:
       def __init__(self):
           self.__hidden = "Base"

   class Derived(Base):
       def __init__(self):
           super().__init__()
           self.__hidden = "Derived"

   obj = Derived()
   print(obj.__dict__)  # {'_Base__hidden': 'Base', '_Derived__hidden': 'Derived'}
   ```

5. **Не путать с одиночным подчеркиванием**:
   Одиночное подчеркивание (например, `_attr`) используется для обозначения "защищенных" атрибутов, 
    которые не должны использоваться вне класса и его подклассов, 
     но это всего лишь соглашение и не обеспечивает никакой реальной защиты:
   ```python
   class MyClass:
       def __init__(self):
           self._protected_attr = "Protected"
   ```

6. **Не использовать манглинг без необходимости**:
   Манглинг имен используется редко и только тогда, когда это действительно необходимо для предотвращения конфликтов имен 
    или для обеспечения скрытия реализации. 
   В большинстве случаев достаточно использовать одиночное подчеркивание.

Пример использования манглинга имен:

```python
class BankAccount:
    def __init__(self, initial_balance):
        self.__balance = initial_balance  # Приватный атрибут

    def deposit(self, amount):
        if amount > 0:
            self.__balance += amount

    def get_balance(self):
        return self.__balance

account = BankAccount(100)
account.deposit(50)
print(account.get_balance())  # 150
# print(account.__balance)  # AttributeError: 'BankAccount' object has no attribute '__balance'
print(account._BankAccount__balance)  # 150 (доступ через манглированное имя)
```

Следуя этим критериям, вы сможете эффективно использовать манглинг имен в Python 
 для управления доступом к атрибутам и предотвращения конфликтов имен.
